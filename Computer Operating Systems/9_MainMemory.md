### Background
- For a program to run, it must be brought from the disk into memory and placed within a process.
- Main memory and registers are the only storage that CPU's can access directly.
- main memory can take many cycles --> causing a stall ; register access is one CPU clock or less
- Cache is between main memory and CPU registers
- protection of memory required to ensure correct operation

### Memory Management Unit (MMU)
- When program turns into a process, there is a virtual/logical portion (virtual image) of the process as well as a physical one
- user program deals with logical addresses and never sees the real physical address
- MMU is the hardware device that maps the virtual/logical address to the physical address at run time.

### Contiguous vs Noncontiguous
- Contiguous -->  all of the process will be mapped into memory
  - Main memory into two partitions:
    - Resident Operating System (in low memory with interrupt vector)
    - User Processes (in high memory)  
  - sf 
- Noncontiguous --> parts of process mapped into memory

As you load processes into memory --> different allocation schemes: **for contiguous**
- First-fit: first hole
- Best-fit: smallest hole
- Worst-fit: largest hole

### Fragmentation:
- External Fragmentation --> total memory space exists but is not contiguous
  - storage compaction --> move memory around so all free memory in one block   
- Internal Fragmentation --> paging ; allocated memory may be slightly larger than requested memory 

### Segmentation 
A program is a collection of segments. (non uniform)

OS will find holes in memory for said segments

Segment table --> Base (where it starts/location) and limit (size)

### Paging
- break logical/virtual memory into equal size pieces and break physical memory into equal size frames.
- pages --> process, frames --> in memory , page table --> page, frame

Issues with paging:
- each process must have its own page table
- page tables must reside in Memory (slower than registers) 

Page Fault --> if page isn't in frame 

Page size ?
- big pages --> internal fragmentation --> memory waste
- small pages --> too many entries 

### TLB Caching Page/Frame Pairs
- TLB --> Translation Look-aside Buffer
- use cache with [(page number:frame number)] pairs
- paging --> 100% overhead aka double the time
- TLB --> 20% overhead
- higher hit ration --> lower overhead 

### Address Translation Scheme
Address generated by CPU is divided into:
- page number (p)  --> m-n
- page offset (d) --> parts of each page (n)

virtual address --> page number and location of within page where instruction is
- represented as [page number, page offset] aka [number of pages bit, size of page bit]
physical address --> frame that it's in and location of where the instruction is within the frame
- represented as [frame number, frame offset] aka [number of frames bit, size of frame bit]

offset of physical and logical should be the same

multiple virtual memory can share the same physical memory 
